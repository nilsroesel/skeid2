{"version":3,"file":"route-collection.js","sourceRoot":"","sources":["../../../../../lib/server/src/routing/route-collection.ts"],"names":[],"mappings":"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","sourcesContent":["import { ClashingRoutesError, DuplicatedEndpointError } from '../../../configuration/error';\nimport { RegisteredEndpoint, RoutePart } from './';\nimport { Maybe } from '../../../global-types';\nimport { getConsumingMimeType } from '../decorators';\n\nexport class RouteCollection {\n\n    public static initializeNew(): RouteCollection {\n        return new RouteCollection(RoutePart.constructFromString(''));\n    }\n\n    public static parsePathParameters( route: Array<string>, urlPath: Array<string> ): { [parameter: string]: any } {\n        const pathParameters = {};\n\n        route.map(RoutePart.constructFromString)\n            .map((part, index) => ({ part, index }))\n            .filter(i => i.part.isPathVariable())\n            .forEach(pathVariableWithIndex => {\n                const parameterName: string = pathVariableWithIndex.part.getName();\n                const parameterValue: string = urlPath[pathVariableWithIndex.index];\n                Object.assign(pathParameters, { [parameterName]: parameterValue });\n            });\n        return pathParameters;\n    }\n\n    private readonly subRoutes: Array<RouteCollection> = new Array<RouteCollection>();\n\n    private endpoints: Array<RegisteredEndpoint<any>> = new Array<RegisteredEndpoint<any>>();\n\n    private constructor(\n        private readonly route: RoutePart,\n        private readonly fullQualifiedRoute: Array<string> = [route.getPart()]\n    ) {}\n\n    public addSubRoute<T>( subRoute: Array<string>, endpoint: RegisteredEndpoint<T> ): void | never {\n        // TODO throw if subRoutes contains undefined/null\n        if ( subRoute.length === 0 ) return;\n        const currentPart: RoutePart = RoutePart.constructFromString(subRoute[0]);\n        if ( currentPart.getPart() === this.route.getPart() ) {\n            this.addSubRoute(subRoute.slice(1), endpoint);\n            return;\n        }\n\n        const newChild: RouteCollection = this.addChild(currentPart);\n        if ( subRoute.length === 1 ) {\n            if ( newChild.endpointExistsWithMimeTypeAndHttpMethod(endpoint.httpMethod, endpoint.restMethod) ) {\n                throw new DuplicatedEndpointError(newChild.fullQualifiedRoute, endpoint.httpMethod);\n            }\n            newChild.endpoints.push({ ...endpoint, route: newChild.fullQualifiedRoute });\n        }\n        newChild.addSubRoute(subRoute.slice(1), endpoint);\n    }\n\n    public findEndpointsByRoute( route: Array<string> ): Array<RegisteredEndpoint<any>> {\n        if ( route.length === 0 ) return [];\n        if ( route.length === 1 ) return this.endpoints;\n\n        if ( this.route.matchesSplitedUrlPart(route[0]) ) {\n            const nextPart: RoutePart = RoutePart.constructFromString(route[1]);\n            const childWithExactString: Maybe<RouteCollection> = this.getChild(nextPart);\n            const childAsPathVariable: Maybe<RouteCollection> = this.getPathVariable();\n\n            return childWithExactString?.findEndpointsByRoute(route.slice(1)) ||\n                childAsPathVariable?.findEndpointsByRoute(route.slice(1)) || []\n        }\n        return [];\n    }\n\n    private addChild( routePart: RoutePart ): RouteCollection {\n        const existingRoutePart: Maybe<RouteCollection> = this.getChild(routePart);\n        if ( existingRoutePart !== undefined ) {\n            return existingRoutePart;\n        }\n\n        if ( routePart.isPathVariable() && this.hasAlreadyPathVariableAsChild() ) {\n            throw new ClashingRoutesError(this.fullQualifiedRoute.concat(routePart.getPart()),\n                this.getPathVariable()?.fullQualifiedRoute || []);\n        }\n\n        const newSubRoute: RouteCollection =\n            new RouteCollection(routePart, this.fullQualifiedRoute.concat(routePart.getPart()));\n        this.subRoutes.push(newSubRoute);\n        return newSubRoute;\n    }\n\n    private getChild( routePart: RoutePart ): Maybe<RouteCollection> {\n        return this.subRoutes.find(part => part.route.getPart() === routePart.getPart());\n    }\n\n    private getPathVariable(): Maybe<RouteCollection> {\n        return this.subRoutes.find(part => part.route.isPathVariable());\n    }\n\n    private hasAlreadyPathVariableAsChild(): boolean {\n        return this.subRoutes.find(part => part.route.isPathVariable()) !== undefined;\n    }\n\n    private endpointExistsWithMimeTypeAndHttpMethod( httpMethod: string, restMethod: Function ): boolean {\n        return this.endpoints\n            .filter(e => e.httpMethod === httpMethod)\n            .map(e => e.restMethod)\n            .find(fn => getConsumingMimeType(fn) === getConsumingMimeType(restMethod)) !== undefined;\n    }\n}\n\n"]}