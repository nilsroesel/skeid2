{"version":3,"file":"request-listener-factory.js","sourceRoot":"","sources":["../../../../../lib/server/src/connectivity/request-listener-factory.ts"],"names":[],"mappings":"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","sourcesContent":["import { IncomingMessage, ServerResponse } from 'http';\nimport { parse, Url } from 'url';\n\nimport { Router } from '../routing/router';\nimport { Request } from './request';\nimport {\n    getBodySchemaFromMethodMetadata,\n    getDeserializerMetadata,\n    getParameterIndexFromMetadata,\n    getParameterSerializer,\n    getProducingDecoratorMetadata,\n    getQueryParameterSchemaFromMetadata,\n    getRequestParameterIndexFromMethodMetaData,\n    getResponseEntityInjectionMetadata,\n    ProducingMetadata,\n    ResponseEntityInjectionMetadata,\n    StatusCodeGenerator\n} from '../decorators';\nimport { Response, ResponseFactory, ResponseEntityFactory } from './response';\nimport { Maybe } from '../../../global-types';\n\nexport type RequestListener = ( request: IncomingMessage, response: ServerResponse ) => void;\n\nexport class RequestListenerFactory {\n\n    constructor( private router: Router ) {}\n\n    public create(): RequestListener {\n        return ( request: IncomingMessage, response: ServerResponse ) => {\n            const requestUrl: Url = parse(request.url || '', true);\n            const responseEntityFactory: ResponseEntityFactory = new ResponseEntityFactory(response);\n            // The request headers from IncomingMessage are always represented in lower case\n            const contentTypeHeader = request.headers['content-type'];\n            const requestContentType: Maybe<string> = Array.isArray(contentTypeHeader) ? contentTypeHeader[0] :\n                contentTypeHeader;\n            Promise.resolve()\n                .then(() => this.router.routeRequest(request.method || '', requestUrl, requestContentType))\n                .then(async mappedEndpoint => {\n                    const responseInjection: Maybe<ResponseEntityInjectionMetadata> =\n                        getResponseEntityInjectionMetadata(mappedEndpoint.restMethod);\n\n                    const resolvedRequest: Request<any, any> = await Request.new(\n                        request,\n                        mappedEndpoint.pathVariables,\n                        requestUrl.query,\n                        getBodySchemaFromMethodMetadata(mappedEndpoint.restMethod),\n                        getQueryParameterSchemaFromMetadata(mappedEndpoint.restMethod)\n                    );\n\n                    // @RequestBody/@PathVariable/@QueryParameter\n                    const callerArguments = createCallerArguments(\n                        mappedEndpoint.restMethod,\n                        resolvedRequest,\n                        responseEntityFactory,\n                        responseInjection\n                    );\n                    const result = await mappedEndpoint.restMethod(callerArguments);\n\n                    const mimeType: string = resolveMimeType(mappedEndpoint.restMethod, result);\n                    const responseEntity: Response = constructResponseBasedOnMimeType(mimeType, responseEntityFactory);\n                    if ( responseInjection === undefined ) {\n                        const statusCode = resolveStatus(mappedEndpoint.restMethod, request.method, result);\n                        responseEntity.status(statusCode);\n                        responseEntity.setHeader('Content-Type', mimeType);\n                        responseEntity.body(result);\n                        return responseEntity;\n                    }\n                    return;\n                })\n                .then((responseEntity: Maybe<Response>) => responseEntity?.respond())\n                .catch(error => {\n                    // TODO Inject error handler\n                    console.log(error);\n                    const mimeType: string = resolveMimeType(error.constructor, error);\n                    const responseEntity: Response = constructResponseBasedOnMimeType(mimeType, responseEntityFactory);\n                    const producingMetadata: ProducingMetadata = getProducingDecoratorMetadata(error.constructor);\n                    const statusCodeGenerator = producingMetadata.statusCode || (() => 500);\n                    responseEntity.status(statusCodeGenerator(error));\n                    responseEntity.setHeader('Content-Type', mimeType);\n                    responseEntity.body(error);\n                    responseEntity.respond();\n                });\n        };\n    }\n\n}\n\nfunction createCallerArguments( restMethod: Function, request: Request<any, any>,\n    responseEntityFactory: ResponseFactory,\n    responseInjection: Maybe<ResponseEntityInjectionMetadata> ): Array<any> {\n        const args: Array<any> = [];\n\n        if ( responseInjection !== undefined ) {\n            const selection = responseInjection.select(responseEntityFactory);\n            args[responseInjection.index] = new (selection.apply(responseEntityFactory))();\n        }\n\n        const requestBodyIndex: Maybe<number> = getRequestParameterIndexFromMethodMetaData(restMethod);\n        if ( requestBodyIndex !== undefined ) args[requestBodyIndex] = request.body;\n\n        assignParametersToArguments(args, restMethod, request.routeParams, 'path:');\n        assignParametersToArguments(args, restMethod, request.queryParams, 'query:');\n\n        return args;\n}\n\nfunction assignParametersToArguments( args: Array<any>, method: Function, on: Object, type: 'path:' | 'query:' ): void {\n    Object.entries(on)\n        .map(entry => ({ key: entry[0], value: entry[1] }))\n        .map(entry => ({\n            ...entry,\n            index: getParameterIndexFromMetadata(method, type + entry.key),\n            serializer: getParameterSerializer(method, type + entry.key)\n        }))\n        .filter(entry => entry.index !== undefined)\n        .forEach(entry => args[entry.index as number] = entry.serializer(entry.value));\n}\n\nfunction constructResponseBasedOnMimeType( mimeType: string, factory: ResponseEntityFactory ): Response {\n    if ( mimeType === 'application/json' ) return new (factory.JsonResponseEntity())();\n\n    if ( mimeType.startsWith('text/') ) return new (factory.TextResponseEntity())();\n\n    return new (factory.ResponseEntity())();\n}\n\nfunction resolveStatus( restMethod: Function, httpMethod: Maybe<string>, resultContent: any ): number {\n    const generator: Maybe<StatusCodeGenerator<any>> = getProducingDecoratorMetadata(restMethod).statusCode;\n    if ( generator !== undefined ) return generator(resultContent);\n\n    if ( resultContent === null || resultContent === undefined ) return 204;\n    if ( httpMethod === 'GET' ) return 200;\n    if ( httpMethod === 'POST' || httpMethod === 'PUT' || httpMethod === 'PATCH' ) return 201;\n    return 204;\n}\n\n\nfunction resolveMimeType( restMethod: Function, restMethodResult: any ): string {\n    let mimeType: string = 'text/plain';\n\n    mimeType = getProducingDecoratorMetadata(restMethod).mimeType || mimeType;\n    if ( restMethodResult?.constructor !== undefined ) {\n        mimeType = getDeserializerMetadata(restMethodResult.constructor).mimeType || mimeType;\n    }\n\n    return mimeType;\n}\n"]}