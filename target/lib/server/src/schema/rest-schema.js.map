{"version":3,"file":"rest-schema.js","sourceRoot":"","sources":["../../../../../lib/server/src/schema/rest-schema.ts"],"names":[],"mappings":"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","sourcesContent":["import { Serializer } from './serializer';\nimport { InvalidSchemaError } from './invalid-schema-error';\nimport { Maybe } from '../../../global-types';\n\n\nexport class RestSchema<T> {\n\n    public static any(): RestSchema<any> {\n        const schema: RestSchema<any> = new RestSchema<any>({}, false);\n        Object.assign(schema, {\n            serialize: ( something: { [property: string]: any} ) => something,\n            getLoggableSchemaDefinition: () => ({}),\n            checkStrictType: () => {}\n        });\n        return schema;\n    }\n\n    public static string(): RestSchema<string> {\n        const schema: RestSchema<string> = new RestSchema<string>('', false);\n        Object.assign(schema, {\n            serialize: ( something: { [property: string]: any} ) => something,\n            getLoggableSchemaDefinition: () => ({ body: 'string'}),\n            checkStrictType: () => {},\n            preProcessor: () => ( something: string ) => something\n        });\n        return schema;\n    }\n\n    private partialTyping: boolean = false;\n\n    constructor( private schemaDefinition: SchemaDefinition<T>, private strictTypeCheck: boolean = true ) {}\n\n    public intersection<T2>( withSchema: RestSchema<T2> ): RestSchema<T & T2> {\n        // Even though the compiler complains. From the logical point\n        // SchemaDefinition<T & T2> equals SchemaDefinition<T> & SchemaDefinition<T2>\n        const newSchemaDefinition: SchemaDefinition<T & T2> = {\n            ...this.schemaDefinition,\n            ...withSchema.schemaDefinition\n        } as SchemaDefinition<T & T2>;\n        return new RestSchema<T & T2>(newSchemaDefinition);\n    }\n\n    public preProcessor(): Function {\n        return JSON.parse;\n    }\n    \n    public serialize( something: { [property: string]: any} ): T | never {\n        if ( this.strictTypeCheck ) {\n            this.checkStrictType(something);\n        }\n        const serialized: Partial<T> = {};\n        const wrongProperties: Array<Maybe<Error>> = Object\n            .entries(this.schemaDefinition).map(entry => {\n                const schemaPropertyKey: string = entry[0];\n                const schemaProperty: SchemaProperty<any> = entry[1] as SchemaProperty<any>;\n                const definitionOptions: SchemaDefinitionOptions<any> = this.getDefinitionOptionsFrom(schemaProperty);\n                const samePropertyFromSomething: unknown | undefined = something[schemaPropertyKey];\n\n                if ( samePropertyFromSomething === undefined && definitionOptions.required ) {\n                    return new Error();\n                }\n\n                if ( samePropertyFromSomething === undefined && definitionOptions.defaultValue !== undefined ) {\n                    Object.assign(serialized, { [schemaPropertyKey]: definitionOptions.defaultValue });\n                    return;\n                }\n\n                if ( samePropertyFromSomething === undefined && !definitionOptions.required ) {\n                    return;\n                }\n                try {\n                    let serializedValue: any = undefined;\n                    if ( definitionOptions.serializer instanceof RestSchema ) {\n                        serializedValue = definitionOptions.serializer.serialize(samePropertyFromSomething as any)\n                    } else if ( typeof definitionOptions.serializer === 'function' ) {\n                        serializedValue = definitionOptions.serializer(samePropertyFromSomething);\n                    }\n                    Object.assign(serialized, { [schemaPropertyKey]: serializedValue })\n                } catch ( error ) {\n                    return error;\n                }\n            }).filter(error => error !== undefined);\n\n        if ( wrongProperties.length > 0 ) {\n            throw new InvalidSchemaError(something, this.getLoggableSchemaDefinition());\n        }\n\n        return serialized as T;\n    }\n\n    public getLoggableSchemaDefinition() {\n        const loggable = {};\n        Object.entries(this.schemaDefinition).forEach(entry => {\n            const schemaPropertyKey: string = entry[0];\n            const definition: any = this.getDefinitionOptionsFrom(entry[1] as any);\n\n            if ( definition.serializer instanceof RestSchema ) {\n                Object.assign(loggable, {[schemaPropertyKey]: definition.serializer.getLoggableSchemaDefinition() });\n            } else {\n                const serializer = (definition.serializer as Function).name;\n                Object.assign(loggable, {[schemaPropertyKey]: { ...definition, serializer } })\n            }\n        });\n        return loggable;\n    }\n\n    asPartialType(): RestSchema<Partial<T>> {\n        const newSchema: RestSchema<Partial<T>> = new RestSchema<Partial<T>>(this.schemaDefinition);\n        newSchema.partialTyping = true;\n        return newSchema;\n    }\n\n    private checkStrictType( something: { [property: string]: any} ): void | never {\n        const hasMorePropertiesThanDefined: boolean = Object.keys(something).filter(key =>\n            Object.keys(this.schemaDefinition).find(k => k === key) === undefined\n        ).length > 0;\n\n        if ( hasMorePropertiesThanDefined ) {\n            throw new InvalidSchemaError(something, this.getLoggableSchemaDefinition());\n        }\n    }\n\n    private getDefinitionOptionsFrom( schemaProperty: SchemaProperty<unknown> ): SchemaDefinitionOptions<unknown> | never {\n        if ( typeof schemaProperty === 'function' || schemaProperty instanceof RestSchema ) {\n            return {\n                serializer: schemaProperty,\n                required: !this.partialTyping && true\n            };\n        }\n        if ( isSchemaDefinitionOptions(schemaProperty) ) {\n            return { ...schemaProperty, required: !this.partialTyping && schemaProperty.required };\n        }\n        throw new TypeError(`A defined Schema Property is not valid.`);\n    }\n\n}\n\nexport type SchemaDefinition<T> = Required<{\n    [Property in keyof T]: SchemaProperty<T[Property]>;\n}>;\n\nexport type SchemaProperty<T> = Serializer<T> | SchemaDefinitionOptions<T> | RestSchema<T>;\n\nexport type SchemaDefinitionOptions<T> = {\n    serializer: Serializer<T> | RestSchema<T>;\n    required?: Maybe<boolean>;\n    defaultValue?: Maybe<T> ;\n}\n\nfunction isSchemaDefinitionOptions( something: Maybe<unknown> ): something is SchemaDefinitionOptions<unknown> {\n    if ( something === undefined ) return false;\n    const serializerIsFunction = typeof (something as SchemaDefinitionOptions<unknown>).serializer === 'function';\n    const requiredIsBooleanOrUndefined = typeof (something as SchemaDefinitionOptions<unknown>).required === 'boolean'\n        || (something as SchemaDefinitionOptions<unknown>).required === undefined;\n    return  serializerIsFunction && requiredIsBooleanOrUndefined;\n}\n"]}