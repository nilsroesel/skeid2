{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../../../lib/server/src/decorators/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import 'reflect-metadata';\nimport { Maybe, Qualifier } from '../../../global-types';\n\nexport function decoratedItemIsMethod( something: unknown ): something is Function {\n    return typeof something === 'function';\n}\n\nexport function copyMetadata( from: any, to: any ): void {\n    Reflect.getMetadataKeys(from).forEach(metadataKey => {\n       const metadata: any = Reflect.getOwnMetadata(metadataKey, from);\n       Reflect.defineMetadata(metadataKey, metadata, to);\n    });\n}\n\nexport function assignOnlyDefinedMetadata<T>( to: any, metadata: string | symbol, value: Maybe<T> ): void {\n    if ( value !== undefined ) {\n        Reflect.defineMetadata(metadata, value, to);\n    }\n}\n\nexport function getNameOfParameter( ofFunction: Function, parameterIndex: number ): string | never {\n    const functionString = ofFunction.toString();\n    const indexOfOpeningBrace = functionString.indexOf('(') + 1;\n    const indexOfClosingBrace = functionString.indexOf(')');\n    const argumentContent = functionString.slice(indexOfOpeningBrace, indexOfClosingBrace);\n    const parameterNames = argumentContent.split(' ').map(name => name.replace(',', ''));\n    const parameterNameAtIndex = parameterNames[parameterIndex];\n\n    if ( parameterNameAtIndex === undefined ) throw new Error('No parameter on this index');\n    const isRestOperatorArgument = parameterNameAtIndex.startsWith('...');\n    if ( isRestOperatorArgument ) throw new Error('Rest Operator is not supported');\n\n    return parameterNameAtIndex;\n}\n\n/* Specific for @PathVariable and @QueryParameter */\n\nexport type SecondArgument = Qualifier | Function | undefined;\nexport function getParameterIndexFromMetadata( from: Function, parameterName: string ): number | undefined {\n    return Reflect.getMetadata(parameterName, from);\n}\n\nexport function registerParameterIndexInMetadata( on: Function, parameterName: string, index: number ): void {\n    Reflect.defineMetadata(parameterName, index, on);\n}\n\nexport function getParameterSerializer( from: Function, parameterName: string ): Function {\n    const registeredSerializer = Reflect.getMetadata(parameterName + ':serializer', from);\n    if ( typeof  registeredSerializer === 'function' ) return registeredSerializer;\n    return <T>(identity: T) => identity;\n}\n\nexport function registerParameterSerializerInMetadata( on: Function, parameterName: string, value: Function ): void {\n    Reflect.defineMetadata(parameterName, value, on);\n}\n\nexport interface ParameterDecoratorFactoryOptions {\n    parameterName: string | undefined;\n    serializer: Function | undefined;\n}\n\nexport type FactoryArgument = Function | string | undefined;\n\nexport function getParameterFactoryOptions( a: FactoryArgument, b: FactoryArgument ): ParameterDecoratorFactoryOptions {\n    let parameterName: string | undefined = undefined;\n    let serializer: Function | undefined = undefined;\n\n    if ( typeof a === 'string' ) {\n        parameterName = a;\n    } else if ( typeof b === 'string' ) {\n        parameterName = b;\n    }\n\n    if ( typeof a === 'function' ) {\n        serializer = a;\n    } else if ( typeof b === 'function' ) {\n        serializer = b;\n    }\n\n    return { parameterName, serializer };\n}\n\nexport function isParameterFactory( firstArg: unknown, secondArg: unknown, thirdArg: unknown ): boolean {\n    return (typeof firstArg === 'function' || typeof firstArg === 'string')\n        && (typeof secondArg === 'function' || typeof secondArg === 'string' || secondArg === undefined)\n        && (typeof thirdArg !== 'number');\n}\n\nexport function handleAsFactory( namespace: string, first: string | Function, other?: string | Function | undefined ) {\n    const options = getParameterFactoryOptions(first, other);\n\n    return ( target: any, propertyKey: Qualifier, parameterIndex: number ) => {\n        let name = options.parameterName;\n        if ( name === undefined ) {\n            name = getNameOfParameter(target[propertyKey], parameterIndex);\n        }\n        registerParameterIndexInMetadata(target[propertyKey],\n            namespace + name,\n            parameterIndex);\n\n        if ( options.serializer !== undefined ) {\n            registerParameterSerializerInMetadata(\n                target[propertyKey],\n                namespace + name + ':serializer',\n                options.serializer\n            );\n        }\n    };\n}\n\n\n"]}